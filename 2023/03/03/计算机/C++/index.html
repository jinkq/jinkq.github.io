

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="https://jkq-pic.oss-cn-shanghai.aliyuncs.com/img/微信图片_20220916104850.jpg">
  <link rel="icon" href="https://jkq-pic.oss-cn-shanghai.aliyuncs.com/img/微信图片_20220916104850.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="冰柠果儿">
  <meta name="keywords" content="">
  
    <meta name="description" content="虚函数，指针&amp;引用，浅拷贝深拷贝，Python vs C++，C++11新特性">
<meta property="og:type" content="article">
<meta property="og:title" content="C++">
<meta property="og:url" content="http://example.com/2023/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA/C++/index.html">
<meta property="og:site_name" content="冰柠果儿">
<meta property="og:description" content="虚函数，指针&amp;引用，浅拷贝深拷贝，Python vs C++，C++11新特性">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-03-03T05:34:32.421Z">
<meta property="article:modified_time" content="2023-03-30T15:08:59.131Z">
<meta property="article:author" content="冰柠果儿">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>C++ - 冰柠果儿</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"♪","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"U9LIqIC6h4LdIbHbvS9engTE-9Nh9j0Va","app_key":"nMLuYyOqdaWa1PXufJuNqFGn","server_url":"https://u9liqic6.lc-cn-e1-shared.com","path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>冰柠果儿</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="C++"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-03-03 13:34" pubdate>
          2023年3月3日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          14k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          114 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">C++</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h2 id="封装、继承、多态"><a href="#封装、继承、多态" class="headerlink" title="封装、继承、多态"></a>封装、继承、多态</h2><ul>
<li><strong>Encapsulation</strong>: Binding the data and function ; allow the user to hide the information for outside world and doesn’t allow the other user to change or modify the internal values of class. Can split a large program into a number of smaller, independent parts to reduce complexity. In a sentence, encapsulation is hiding the implementation details of a module from its user. Class is a type of encapsulation and abstraction.</li>
<li><strong>Inheritance</strong>: Classes are created in hierarchies, allows the structure and methods in one class to be passed down the hierarchy. That means less programming is required when adding functions to complex systems.</li>
<li><strong>Polymorphism</strong>: Single name can have multiple meanings, depends on the situation. Enable one entity to be used as a general category for different types of actions.</li>
</ul>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>类函数，子类可以各有各的实现，子类的虚函数还是虚函数</p>
<p>在运行期间确定对象实际类型</p>
<p>当一个类带有虚函数时，编译系统会为该类构造一个虚函数表（位于类内其他成员前面），是一个指针数组，存放每个虚函数的入口地址。系统在进行动态联编的时间开销很少，提高了多态性的效率</p>
<p>动态联编：对象指针通过虚指针找到虚表，从虚表中查找对应的虚函数地址进行调用</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>A memory location to store data for a program </p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>对象是一个变量，可以包含其他变量和函数。C++ 中的对象可以定义为类的实例，类是一种用户定义的数据类型，其中包含属性和方法（函数）。对象是类的实例化，通过使用类定义来创建。</p>
<p>It is a variable that can contain other variables and functions. Objects in C++ can be defined as instances of a class, which is a user-defined data type that contains attributes and methods.</p>
<h2 id="指针-amp-引用"><a href="#指针-amp-引用" class="headerlink" title="指针 &amp; 引用"></a>指针 &amp; 引用</h2><p>指针是一个变量，它存储另一个变量的地址。我们可以通过指针访问和修改存储在另一个变量的地址处的值。指针通常用于动态分配内存、在函数之间传递参数和处理数组。</p>
<p>引用是一个别名，它给一个变量起了另一个名称。与指针不同，引用本身不是一个对象，而只是一个已经存在对象的别名。当我们使用引用时，实际上是在使用与引用绑定的变量。引用通常用于避免复制大型对象、创建函数的别名参数和使代码更易读。</p>
<p>A pointer is a variable that stores the address of another variable. We can access and modify the value stored at the address of another variable using a pointer. Pointers are typically used for dynamic memory allocation, passing parameters between functions, and processing arrays.</p>
<p>A reference is an alias that gives another name to a variable. Unlike a pointer, a reference itself is not an object, but rather just an alias for an existing object. When we use a reference, we are actually using the variable that is bound to the reference. References are typically used to avoid copying large objects, create alias parameters for functions, and make code more readable.</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><ol>
<li><p>栈内存管理：C++通过栈来管理函数调用时的局部变量。每当函数被调用时，编译器会自动在栈上为其分配一段内存，当函数执行完毕后，这段内存会自动被释放。栈内存的大小是固定的，因此只适合存储大小已知且较小的数据。</p>
</li>
<li><p>堆内存管理：在C++中，我们可以使用new和delete关键字来动态地分配和释放堆内存。堆内存是由程序员手动申请的，在程序运行时动态分配和释放。由于堆内存的大小是动态变化的，因此适合存储较大的数据结构和对象。但是，需要注意的是，在使用完堆内存后，程序员需要手动释放这段内存，否则可能会造成内存泄漏的问题。</p>
</li>
<li><p>Stack memory management: C++ manages local variables during function calls via the stack. Each time a function is called, the compiler automatically allocates a block of memory on the stack, and the memory is automatically deallocated when the function completes. The size of the stack memory is fixed and is suitable for storing small data that has a known size.</p>
</li>
<li><p>Heap memory management: In C++, we can use the keywords “new” and “delete” to dynamically allocate and deallocate memory on the heap. Heap memory is allocated and deallocated manually by programmers during runtime. Since the size of heap memory is dynamic, it is suitable for storing larger data structures and objects. However, it is important to note that after using heap memory, programmers must manually release the memory to avoid memory leaks.</p>
</li>
</ol>
<h3 id="栈和堆"><a href="#栈和堆" class="headerlink" title="栈和堆"></a>栈和堆</h3><p>在C++中，栈（stack）和堆（heap）是两种内存分配方式。栈是由系统自动分配和释放的一块连续内存区域，用于存储函数调用时的局部变量、函数参数以及函数调用的返回地址等。栈的大小是固定的，它的管理方式是先进后出（LIFO）。这意味着最后被分配的内存先被释放，栈上的数据访问速度比堆要快，但是它的大小受限，不适合存储大量的数据。</p>
<p>堆是由程序员手动申请和释放的一块内存区域，它的大小不是固定的。程序员可以在运行时动态地分配和释放堆内存，用于存储较大的数据结构和对象等。堆的管理方式是任意的，它不像栈那样有固定的大小和访问顺序。在堆上分配内存需要显式地使用new操作符，而释放内存则需要使用delete操作符。如果程序员不释放已经分配的堆内存，就会导致内存泄漏的问题，因为堆上分配的内存不会自动释放。</p>
<p>需要注意的是，栈和堆的使用场景不同，程序员需要根据需要选择合适的内存分配方式。一般来说，较小的变量可以放在栈上，较大的数据结构和对象则需要放在堆上。同时，C++中也提供了一些辅助管理内存的工具，比如智能指针等。</p>
<p>In C++, the stack and the heap are two different memory allocation mechanisms. The stack is a contiguous block of memory that is automatically allocated and deallocated by the system, used to store local variables, function parameters, and return addresses during function calls. The size of the stack is fixed, and it is managed in a last-in, first-out (LIFO) manner. This means that the most recently allocated memory is released first. Accessing data on the stack is faster than the heap, but the stack has limited size and is not suitable for storing a large amount of data.</p>
<p>The heap is a block of memory that is manually allocated and deallocated by the programmer, and its size is not fixed. Programmers can dynamically allocate and deallocate memory on the heap during runtime, used to store large data structures and objects. The management of the heap is arbitrary, and it does not have a fixed size or access order like the stack. Allocating memory on the heap requires explicit use of the “new” operator, while releasing memory requires the “delete” operator. If the programmer does not release the allocated heap memory, it can cause memory leaks because the memory allocated on the heap is not automatically released.</p>
<p>It should be noted that the stack and the heap have different use cases, and programmers need to choose the appropriate memory allocation mechanism based on their needs. Generally, smaller variables can be placed on the stack, while larger data structures and objects should be placed on the heap. Additionally, C++ provides some tools to assist with memory management, such as smart pointers.</p>
<h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>Memory leak would happen if the pointer is dereferenced while the memory of the dynamic variable that the pointer used to point to is not freed.</p>
<h2 id="浅拷贝-vs-深拷贝"><a href="#浅拷贝-vs-深拷贝" class="headerlink" title="浅拷贝 vs 深拷贝"></a>浅拷贝 vs 深拷贝</h2><ul>
<li><p>赋值：得到对象地址，共用对象内容，所有变量都会随之变化</p>
</li>
<li><p>浅拷贝：拷贝一层，更改<strong>引用类型</strong>（对象、数组都是引用类型）的<strong>数据</strong>时，拷贝的对象还是能被影响，如果拷贝的对象里还有子对象的话，那子对象拷贝其是也只是得到一个地址指向而已</p>
</li>
<li><p>深拷贝：递归地拷贝，更改引用类型原对象也不变</p>
</li>
<li><p>Assignment: Obtain the object address, share the object content, and all variables will change accordingly</p>
</li>
<li><p>Shallow copy: When copying a layer of data of a reference type (both objects and arrays are reference types), the copied object can still be affected. If there are any sub objects in the copied object, the sub object copy is only to obtain an address point</p>
</li>
<li><p>Deep copy: copy recursively, changing the reference type and keeping the original object unchanged</p>
</li>
</ul>
<p>浅拷贝创建一个新对象，该对象存储对原始对象相同内存位置的引用。换句话说，新对象只是指向原始对象内存位置的指针。对新对象进行的任何更改也会反映在原始对象上，反之亦然。这意味着浅拷贝并不创建原始对象的新实例，而只是创建对同一实例的新引用。当我们需要快速创建对象的副本而不在内存中创建新对象实例时，通常使用浅拷贝。</p>
<p>深拷贝则创建一个新对象并为其所有内容分配内存。在这种情况下，新对象与原始对象完全独立，对新对象进行的任何更改都不会影响原始对象。当我们需要修改对象的副本而不影响原始对象时，通常使用深拷贝。</p>
<p>A shallow copy creates a new object that stores references to the same memory locations as the original object. In other words, the new object is just a pointer to the original object’s memory locations. Any changes made to the new object will also be reflected in the original object, and vice versa. This means that shallow copy does not create a new instance of the original object, but rather a new reference to the same instance. Shallow copy is often used when we need to create a copy of an object quickly, without creating a new object instance in memory.</p>
<p>A deep copy, on the other hand, creates a new object and allocates memory for all its contents. In this case, the new object is completely independent of the original object, and any changes made to the new object will not affect the original object. Deep copy is often used when we need to modify a copy of an object without affecting the original object.</p>
<h2 id="Python-vs-C"><a href="#Python-vs-C" class="headerlink" title="Python vs C++"></a>Python vs C++</h2><ol>
<li><p>类型：C++是一种静态类型语言，这意味着变量必须在编译时声明其类型，并且在程序运行时无法更改类型。Python是一种动态类型语言，这意味着变量的类型在程序运行时可以更改，并且无需显式声明。</p>
</li>
<li><p>性能：由于C++是一种编译语言，它通常比Python更快。Python是一种解释型语言，通常比C++慢一些。但是，Python有许多用于优化性能的工具和库。</p>
</li>
<li><p>内存管理：在C++中，程序员必须手动管理内存，包括分配和释放内存。在Python中，内存管理是由解释器自动处理的，有垃圾回收机制。</p>
</li>
<li><p>python对函数的参数类型与返回值类型没有严格限定，c++有</p>
</li>
<li><p>python不需要定义变量就能使用，c++需要先定义才能使用</p>
</li>
<li><p>python中的变量作用域更广，c++中的作用域更严格</p>
<p>python中循环内部定义的变量在外面可以用，但是c++不行</p>
</li>
<li><p>Type: C++ is a statically typed language, which means that variables must declare their type at compile-time and cannot change type at runtime. Python is a dynamically typed language, which means that variables can change type at runtime and do not need to be explicitly declared.</p>
</li>
<li><p>Performance: Because C++ is a compiled language, it is generally faster than Python. Python is an interpreted language and is generally slower than C++. However, Python has many tools and libraries for optimizing performance.</p>
</li>
<li><p>Memory management: In C++, programmers must manually manage memory, including allocating and freeing memory. In Python, memory management is handled automatically by the interpreter, has garbage collection.</p>
</li>
</ol>
<h2 id="Python为什么比C-慢"><a href="#Python为什么比C-慢" class="headerlink" title="Python为什么比C++慢"></a>Python为什么比C++慢</h2><p>Python is interpreted and executed sentence by sentence, with a high degree of abstraction. C++ is compiled first and converted to machine code, without dynamic typing or dynamic checking.</p>
<h2 id="C-11新特性"><a href="#C-11新特性" class="headerlink" title="C++11新特性"></a>C++11新特性</h2><ol>
<li><p>auto关键字：可以用于自动推断变量类型，减少重复代码，提高代码可读性。</p>
</li>
<li><p>nullptr关键字：代表空指针，替代了NULL和0。</p>
</li>
<li><p>Range-based for循环：一种新的循环语法，可以用：遍历数组、向量、列表等容器中的元素。</p>
</li>
<li><p>Lambda表达式（lambda expression）：一种轻量级的匿名函数（anonymous function），可以在需要时动态创建，减少了代码量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> lambda = [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) &#123; <span class="hljs-keyword">return</span> a + b; &#125;;<br>std::cout &lt;&lt; <span class="hljs-built_in">lambda</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 输出3</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>Move语义：通过std::move函数，可以将资源的所有权从一个对象移动到另一个对象，减少了不必要的拷贝构造函数和析构函数的调用，提高了程序效率。</p>
</li>
<li><p>右值引用：提供了一种新的引用类型，可以绑定到临时对象和表达式上，使得临时对象的创建和销毁更加高效。</p>
</li>
<li><p>列表初始化：一种新的初始化语法，可以通过{}对列表进行初始化，使得代码更加简洁和易于理解。</p>
</li>
<li><p>智能指针：提供了一种管理动态内存的方式，可以自动进行内存释放，避免内存泄漏和悬空指针。std::unique_ptr、std::shared_ptr和std::weak_ptr</p>
</li>
<li><p>constexpr</p>
<p>constexpr修饰的是真正的常量，它会在编译期间就会被计算出来，整个运行过程中都不可以被改变，constexpr可以用于修饰函数，这个函数的返回值会尽可能在编译期间被计算出来当作一个常量，但是如果编译期间此函数不能被计算出来，那它就会当作一个普通函数被处理</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;<br>   <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;<br>   <span class="hljs-built_in">func</span>(i);<span class="hljs-comment">// 普通函数</span><br>   <span class="hljs-built_in">func</span>(<span class="hljs-number">2</span>);<span class="hljs-comment">// 编译期间就会被计算出来</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>final &amp; override：final修饰一个类或虚函数，表示禁止该类进一步派生和虚函数的进一步重载</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Base</span> <span class="hljs-keyword">final</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;base&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base&#123; <span class="hljs-comment">// 编译失败，final修饰的类不可以被继承</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;derived&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>override用于修饰派生类中的成员函数，标明该函数重写了基类函数，如果一个函数声明了override但父类却没有这个虚函数，编译报错，使用override关键字可以避免开发者在重写基类函数时无意产生的错误</p>
</li>
</ol>
<h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><h4 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h4><p>unique_ptr是一种独占式智能指针，它拥有被指向对象的独占权，不能被拷贝，只能移动。当unique_ptr被销毁时，它所指向的对象也将被销毁。unique_ptr适用于管理单个对象的所有权，是一种安全、高效的内存管理方式。</p>
<p>unique_ptr的主要作用是：</p>
<ul>
<li>管理动态分配的内存对象的生命周期，可以确保内存的正确释放。</li>
<li>通过移动语义，实现所有权的转移，防止悬空指针的出现，避免内存泄漏。</li>
</ul>
<h4 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h4><p>shared_ptr是一种共享式智能指针，多个shared_ptr可以共享同一块内存，可以记录有多少个shared_ptr共同拥有这块内存。当共享计数器归零时，该内存将被自动销毁。shared_ptr支持拷贝和移动操作。</p>
<p>shared_ptr的主要作用是：</p>
<ul>
<li>管理动态分配的内存对象的生命周期，可以确保内存的正确释放。</li>
<li>可以在多个地方共享同一份内存资源，避免了内存多次释放或者使用悬空指针的问题。</li>
</ul>
<p>shared_ptr 通过一个控制块来实现共享计数器的维护，该控制块包含有关指向对象的引用计数和删除器等信息。</p>
<h4 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h4><p>weak_ptr是一种弱引用智能指针，它不会增加被指向对象的引用计数，也不拥有对象的所有权，不能直接访问其指向的对象，必须通过lock()成员函数获取一个shared_ptr才能访问。当shared_ptr被销毁时，weak_ptr不会影响该对象的销毁。要与std::shared_ptr一起使用，一个std::weak_ptr对象看作是std::shared_ptr对象管理的资源的观察者，不影响共享资源的生命周期</p>
<p>weak_ptr的主要作用是：</p>
<ul>
<li>解决shared_ptr的循环引用问题，避免内存泄漏。</li>
<li>用于观察shared_ptr所管理的对象，防止shared_ptr被释放后，还有其他地方使用悬空指针的问题。</li>
</ul>
<p>weak_ptr通过lock()成员函数可以获取一个shared_ptr，用于访问被指向的对象，如果没有可用的shared_ptr，则lock()会返回一个空的shared_ptr。</p>
<h5 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h5><p>循环引用是指两个或多个对象之间相互引用，导致它们的引用计数不为0，无法被自动释放，从而导致内存泄漏。在使用<code>shared_ptr</code>时，如果出现循环引用，将会导致对象无法被正确地释放，从而出现内存泄漏问题。</p>
<p><code>weak_ptr</code>可以通过对<code>shared_ptr</code>进行弱引用来解决循环引用问题。<code>weak_ptr</code>可以访问<code>shared_ptr</code>所指向的对象，但不会改变其引用计数。当<code>shared_ptr</code>所指向的对象被释放时，所有的<code>weak_ptr</code>都会自动失效，无需手动释放内存。</p>
<h4 id="悬空指针-dangling-pointer"><a href="#悬空指针-dangling-pointer" class="headerlink" title="悬空指针 dangling pointer"></a>悬空指针 dangling pointer</h4><p>C++中的悬空指针是指一个指针变量指向了已经被释放或者不存在的内存地址。</p>
<p>当一个指针变量指向一个已经释放的内存地址时，该指针变量就变成了一个悬空指针。这种情况可能会导致程序崩溃或者出现其他错误，因为程序试图在无效的内存地址上执行操作。</p>
<p>悬空指针通常是由于程序员没有正确管理内存所导致的，例如在使用 <code>delete</code> 关键字释放指针指向的内存后，却继续使用指针变量，这会导致指针变量成为悬空指针。</p>
<p>为了避免悬空指针，程序员应该在使用完指针后，及时将其指向 <code>nullptr</code> 或者重新赋值为有效的内存地址。此外，使用智能指针和 RAII 等技术也可以有效避免悬空指针的问题。</p>
<h3 id="std-move"><a href="#std-move" class="headerlink" title="std::move"></a>std::move</h3><h4 id="move的作用"><a href="#move的作用" class="headerlink" title="move的作用"></a>move的作用</h4><p><code>std::move</code> 是 C++11 标准中的一个函数模板，用于将对象的值转移（移动）到另一个对象中，同时将原来对象的值置为默认值（通常是零值或者空值）。这个操作称为“移动语义”，可以显著提高程序的性能。</p>
<p>在 C++ 中，当我们需要复制一个对象时，我们通常会使用拷贝构造函数或拷贝赋值运算符。但是在某些情况下，我们并不需要完全复制一个对象，而只需要转移它的资源所有权，即将指向这些资源的指针或引用从原来的对象中“移动”到新的对象中。这种情况下，使用 <code>std::move</code> 可以实现“移动语义”。</p>
<p>具体来说，使用 <code>std::move</code> 可以将一个左值转换为右值引用，以便进行移动语义操作。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; v1 &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; v2 &#123;std::<span class="hljs-built_in">move</span>(v1)&#125;;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;v1 size = &quot;</span> &lt;&lt; v1.<span class="hljs-built_in">size</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 输出 0</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;v2 size = &quot;</span> &lt;&lt; v2.<span class="hljs-built_in">size</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 输出 3</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上面的代码中，我们创建了两个 <code>std::vector&lt;int&gt;</code> 对象 <code>v1</code> 和 <code>v2</code>。然后，我们使用 <code>std::move</code> 将 <code>v1</code> 的资源所有权转移给 <code>v2</code>，从而避免了不必要的拷贝操作，并且可以提高程序的性能。最后，我们打印了 <code>v1</code> 和 <code>v2</code> 的大小，可以看到 <code>v1</code> 的大小为 0，因为其资源已经被移动到了 <code>v2</code> 中。</p>
<p>需要注意的是，使用 <code>std::move</code> 不会真正地移动数据，而只是将对象的指针或引用转移到另一个对象中。因此，在移动完成后，原来的对象可能处于未定义的状态，不应该再使用它。</p>
<p>The purpose of <code>std::move</code> is to allow objects to be efficiently moved or transferred between scopes, rather than copied. It does this by converting an lvalue to an rvalue reference, which enables the move constructor or move assignment operator to be called, if they exist. This can lead to improved performance in cases where copying is expensive or unnecessary.</p>
<h4 id="move和拷贝的比较"><a href="#move和拷贝的比较" class="headerlink" title="move和拷贝的比较"></a>move和拷贝的比较</h4><ol>
<li>避免了不必要的拷贝操作：使用拷贝构造函数或拷贝赋值运算符进行复制操作时，会将对象的数据逐一复制到新的对象中，这个过程可能非常耗时。而使用 <code>std::move</code> 可以将对象的资源所有权转移到新的对象中，避免了这个耗时的复制操作。</li>
<li>可以利用移动构造函数和移动赋值运算符：对于许多对象，移动操作的时间复杂度比拷贝操作低很多，因为移动操作不需要复制数据，而只需要转移指针或引用。使用 <code>std::move</code> 可以将对象转换为右值引用，从而让编译器使用移动构造函数或移动赋值运算符，提高程序的性能。</li>
</ol>
<p>Using <code>std::move</code> can be better than direct copying because it avoids unnecessary copying operations, which can be slow and resource-intensive. Instead, it transfers ownership of an object’s resources to a new object, which can be faster and more efficient. Additionally, <code>std::move</code> can take advantage of move constructors and move assignment operators, which can be faster than copy constructors and copy assignment operators for many objects.</p>
<h4 id="move和指针的区别"><a href="#move和指针的区别" class="headerlink" title="move和指针的区别"></a>move和指针的区别</h4><p><code>std::move</code> 和指针的主要区别是，<code>std::move</code> 本质上是将一个左值强制转换为右值引用，从而实现“移动语义”，而指针只是一个指向内存地址的变量，没有实现“移动语义”。</p>
<p>具体来说，使用 <code>std::move</code> 可以将对象的资源所有权转移给另一个对象，同时将原来对象的值置为默认值，这个过程被称为“移动语义”。而指针只是一个变量，它存储了指向某个内存地址的值。对指针进行赋值或传递时，只是将指针的值传递给另一个变量或函数，不会影响指针所指向的内存地址的内容或所有权。</p>
<p>另外，使用指针需要自己手动管理内存分配和释放，容易引起内存泄漏或悬空指针等问题。而使用 <code>std::move</code> 可以避免这些问题，因为移动语义可以确保资源的所有权被正确地管理。</p>
<p>he main difference between <code>std::move</code> and a pointer is that <code>std::move</code> provides move semantics, while a pointer only stores a memory address. <code>std::move</code> enables objects to be transferred between scopes more efficiently, by transferring ownership of an object’s resources to a new object.</p>
<p>A pointer only stores the address of an object in memory, and does not provide any special semantics for transferring ownership or managing resources. Additionally, using pointers requires manual memory management, which can be error-prone and lead to memory leaks or dangling pointers.</p>
<h3 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h3><p>左值表示一个表达式所代表的内存位置，即一个可寻址的内存区域，可以被修改。左值可以出现在赋值操作的左边，表示将右边的值赋给左边的内存位置，也可以出现在表达式的任何位置。</p>
<p>例如，变量、数组元素和结构体成员都是左值。</p>
<p>右值表示表达式的值，即一些无法被修改的临时数据，通常出现在赋值操作的右边，表示将该值赋给左边的内存位置，或者在表达式中的常量或计算结果。</p>
<p>例如，字面常量、函数返回值和表达式计算结果都是右值。</p>
<p><strong>概念1：</strong></p>
<p>左值：可以放到等号左边的东西叫左值。</p>
<p>右值：不可以放到等号左边的东西就叫右值。</p>
<p><strong>概念2</strong>：</p>
<p>左值：可以取地址并且有名字的东西就是左值。</p>
<p>右值：不能取地址的没有名字的东西就是右值。</p>
<h4 id="将亡值"><a href="#将亡值" class="headerlink" title="将亡值"></a>将亡值</h4><p>将亡值是指C++11新增的和右值引用相关的表达式，通常指将要被移动的对象、T&amp;&amp;函数的返回值、std::move函数的返回值、转换为T&amp;&amp;类型转换函数的返回值，将亡值可以理解为即将要销毁的值，通过“盗取”其它变量内存空间方式获取的值，在确保其它变量不再被使用或者即将被销毁时，可以避免内存空间的释放和分配，延长变量值的生命周期，常用来完成移动构造或者移动赋值的特殊任务。</p>
<h4 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h4><p>如果使用右值引用，那表达式等号右边的值需要时右值，可以使用std::move函数强制把左值转换为右值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">4</span>;<br><span class="hljs-type">int</span> &amp;&amp;b = a; <span class="hljs-comment">// error, a是左值</span><br><span class="hljs-type">int</span> &amp;&amp;c = std::<span class="hljs-built_in">move</span>(a); <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure>

<p>右值引用具有移动语义，可以将一个右值引用绑定到临时对象上，然后将这个对象的状态转移给新的对象。这种操作称为移动语义。</p>
<p>移动语义可以提高程序的效率和性能，尤其是在进行资源管理时。例如，一个对象在拷贝时需要分配内存，而移动时只需要将指向该内存的指针转移即可，避免了复制内存的开销。</p>
<h5 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h5><p>移动语义，可以理解为转移所有权，之前的拷贝是对于别人的资源，自己重新分配一块内存存储复制过来的资源，而对于移动语义，类似于转让或者资源窃取的意思，对于那块资源，转为自己所拥有，别人不再拥有也不会再使用，通过C++11新增的移动语义可以省去很多拷贝负担，通过移动构造函数。</p>
<p>移动语义仅针对于那些实现了移动构造函数的类的对象，对于那种基本类型int、float等没有任何优化作用，还是会拷贝，因为它们实现没有对应的移动构造函数。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" class="category-chain-item">计算机</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>C++</div>
      <div>http://example.com/2023/03/03/计算机/C++/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>冰柠果儿</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年3月3日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA/Python/" title="Python">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Python</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/03/02/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" title="神经网络">
                        <span class="hidden-mobile">神经网络</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
